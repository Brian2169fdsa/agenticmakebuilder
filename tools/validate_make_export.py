"""
Validate Make Export

Validates a Make.com blueprint JSON generated by generate_make_export.py.
Performs structural checks against the Make.com blueprint format.

Input:  blueprint (dict) — Make.com export JSON
        registry (dict, optional) — loaded module registry for module checks
Output: structured validation report dict

Rule categories:
  MR — Make Root Structure (5 rules)
  MF — Make Flow Integrity (8 rules)
  MM — Make Module Structure (7 rules)
  MT — Make Router/Routes (4 rules)
  MC — Make Credentials (3 rules)
  MD — Make Designer/Metadata (3 rules)

Deterministic. No network calls. No Make API calls. Pure structural validation.
"""

import re
from datetime import datetime


VALID_ONERROR_DIRECTIVES = {"ignore", "resume", "break", "rollback", "commit"}
CREDENTIAL_PLACEHOLDER_PATTERN = re.compile(r"^__[A-Z_]+_CONNECTION__$")


def validate_make_export(blueprint, registry=None):
    """Validate a Make.com blueprint JSON for structural correctness.

    Args:
        blueprint: The Make.com blueprint dict to validate.
        registry: Optional loaded module registry for cross-referencing.
                  If None, module-specific checks are skipped.

    Returns:
        dict with:
            - valid: bool — True if zero errors
            - errors: list of error dicts
            - warnings: list of warning dicts
            - checks_run: int
            - checks_passed: int
            - checks_failed: int
            - timestamp: str (ISO 8601)
    """
    errors = []
    warnings = []
    checks_run = 0
    checks_passed = 0

    modules_dict = {}
    if registry:
        modules_dict = registry.get("modules", {})

    def _error(rule_id, message, module_id=None, context=None):
        errors.append({
            "rule_id": rule_id,
            "severity": "error",
            "message": message,
            "module_id": module_id,
            "context": context or {}
        })

    def _warn(rule_id, message, module_id=None, context=None):
        warnings.append({
            "rule_id": rule_id,
            "severity": "warning",
            "message": message,
            "module_id": module_id,
            "context": context or {}
        })

    def _check(rule_id, condition, error_msg, warn=False, module_id=None, context=None):
        nonlocal checks_run, checks_passed
        checks_run += 1
        if condition:
            checks_passed += 1
            return True
        if warn:
            _warn(rule_id, error_msg, module_id, context)
        else:
            _error(rule_id, error_msg, module_id, context)
        return False

    # ===== MR — Make Root Structure =====

    # MR-001: Blueprint is a dict
    _check("MR-001", isinstance(blueprint, dict),
           "Blueprint must be a JSON object (dict)")
    if not isinstance(blueprint, dict):
        return _build_report(errors, warnings, checks_run, checks_passed)

    # MR-002: Has 'name' field
    _check("MR-002", "name" in blueprint and isinstance(blueprint.get("name"), str),
           "Blueprint must have a 'name' string field")

    # MR-003: Has 'flow' array
    flow = blueprint.get("flow")
    _check("MR-003", isinstance(flow, list),
           f"Blueprint must have a 'flow' array, got {type(flow).__name__}")
    if not isinstance(flow, list):
        flow = []

    # MR-004: Has 'metadata' object
    metadata = blueprint.get("metadata")
    _check("MR-004", isinstance(metadata, dict),
           "Blueprint must have a 'metadata' object")

    # MR-005: Flow is not empty
    _check("MR-005", len(flow) > 0,
           "Blueprint flow array is empty (must have at least a trigger)")

    # ===== MF — Make Flow Integrity =====

    # Collect all module IDs by traversing the full flow tree
    all_ids = []
    all_modules_flat = []
    _collect_modules_recursive(flow, all_ids, all_modules_flat)

    # MF-001: All module IDs are integers
    for mid in all_ids:
        _check("MF-001", isinstance(mid, int),
               f"Module ID must be integer, got {type(mid).__name__}: {mid}",
               module_id=mid)

    # MF-002: All module IDs are unique
    seen_ids = set()
    for mid in all_ids:
        _check("MF-002", mid not in seen_ids,
               f"Duplicate module ID: {mid}",
               module_id=mid)
        seen_ids.add(mid)

    # MF-003: First flow item is the trigger (id should be 1 by convention)
    if flow:
        _check("MF-003", flow[0].get("id") == 1,
               f"First module in flow should be trigger (id=1), got id={flow[0].get('id')}",
               module_id=flow[0].get("id"))

    # MF-004: Every module has 'id' field
    for mod in all_modules_flat:
        _check("MF-004", "id" in mod,
               "Module missing 'id' field",
               context={"module": mod.get("module", "unknown")})

    # MF-005: Every module has 'module' field (module type identifier)
    for mod in all_modules_flat:
        mid = mod.get("id", "?")
        _check("MF-005", "module" in mod and isinstance(mod.get("module"), str),
               f"Module {mid} missing 'module' type identifier",
               module_id=mid)

    # MF-006: Every module has 'version' field
    for mod in all_modules_flat:
        mid = mod.get("id", "?")
        _check("MF-006", "version" in mod and isinstance(mod.get("version"), int),
               f"Module {mid} missing integer 'version' field",
               module_id=mid)

    # MF-007: Module types exist in registry (if registry provided)
    if modules_dict:
        for mod in all_modules_flat:
            mid = mod.get("id", "?")
            mod_type = mod.get("module", "")
            _check("MF-007", mod_type in modules_dict,
                   f"Module {mid} type '{mod_type}' not in registry",
                   module_id=mid, context={"module": mod_type})

    # MF-008: No unreachable modules (orphan check)
    # In Make blueprint, all modules should be in the flow tree.
    # Since we collect modules by traversal, orphans would be modules
    # listed elsewhere. We check that flow coverage is complete.
    if flow:
        flow_id_set = set(all_ids)
        checks_run += 1
        checks_passed += 1  # If we got here, all modules are in the tree

    # ===== MM — Make Module Structure =====

    for mod in all_modules_flat:
        mid = mod.get("id", "?")

        # MM-001: Has 'metadata' with 'designer' (x, y)
        mod_meta = mod.get("metadata")
        has_designer = (
            isinstance(mod_meta, dict)
            and isinstance(mod_meta.get("designer"), dict)
            and "x" in mod_meta.get("designer", {})
            and "y" in mod_meta.get("designer", {})
        )
        _check("MM-001", has_designer,
               f"Module {mid} missing metadata.designer with x,y positions",
               module_id=mid)

        # MM-002: Has 'parameters' (can be empty dict)
        # Routers may have mapper=None and no parameters, which is valid
        is_router = mod.get("module") == "builtin:BasicRouter"
        if not is_router:
            _check("MM-002", "parameters" in mod,
                   f"Module {mid} missing 'parameters' field",
                   module_id=mid)

        # MM-003: 'mapper' is dict or absent (not other types)
        mapper = mod.get("mapper")
        if mapper is not None:
            _check("MM-003", isinstance(mapper, dict),
                   f"Module {mid} mapper must be dict or null, got {type(mapper).__name__}",
                   module_id=mid)

        # MM-004: 'onerror' is a list if present
        onerror = mod.get("onerror")
        if onerror is not None:
            _check("MM-004", isinstance(onerror, list),
                   f"Module {mid} onerror must be an array, got {type(onerror).__name__}",
                   module_id=mid)

            # MM-005: Each onerror entry has valid directive
            if isinstance(onerror, list):
                for entry in onerror:
                    directive = entry.get("directive") if isinstance(entry, dict) else None
                    _check("MM-005", directive in VALID_ONERROR_DIRECTIVES,
                           f"Module {mid} has invalid onerror directive: {directive!r}",
                           module_id=mid)

        # MM-006: 'filter' structure is valid if present
        filt = mod.get("filter")
        if filt is not None:
            _check("MM-006",
                   isinstance(filt, dict)
                   and "name" in filt
                   and "conditions" in filt
                   and isinstance(filt.get("conditions"), list),
                   f"Module {mid} has malformed filter (needs 'name' and 'conditions' array)",
                   module_id=mid)

            # Validate condition entries
            if isinstance(filt, dict) and isinstance(filt.get("conditions"), list):
                for or_group in filt["conditions"]:
                    _check("MM-006",
                           isinstance(or_group, list),
                           f"Module {mid} filter conditions OR-group must be an array",
                           module_id=mid)
                    if isinstance(or_group, list):
                        for cond in or_group:
                            _check("MM-006",
                                   isinstance(cond, dict) and "a" in cond and "o" in cond,
                                   f"Module {mid} filter condition must have 'a' and 'o' fields",
                                   module_id=mid)

        # MM-007: Version matches registry (warning, if registry available)
        if modules_dict:
            mod_type = mod.get("module", "")
            reg_entry = modules_dict.get(mod_type)
            if reg_entry:
                _check("MM-007", mod.get("version") == reg_entry.get("version"),
                       f"Module {mid} version {mod.get('version')} does not match "
                       f"registry version {reg_entry.get('version')} for '{mod_type}'",
                       warn=True, module_id=mid)

    # ===== MT — Make Router/Routes =====

    routers = [m for m in all_modules_flat if m.get("module") == "builtin:BasicRouter"]
    # Also check flow items directly for routes (routers aren't in all_modules_flat
    # with their routes — we need to find them in the flow tree)
    _validate_routers_recursive(flow, errors, warnings, _check)

    # ===== MC — Make Credentials =====

    # MC-001: __IMTCONN__ values are placeholder strings (not real numeric IDs)
    for mod in all_modules_flat:
        mid = mod.get("id", "?")
        params = mod.get("parameters", {})
        if isinstance(params, dict) and "__IMTCONN__" in params:
            imtconn = params["__IMTCONN__"]
            _check("MC-001",
                   isinstance(imtconn, str) and not imtconn.isdigit(),
                   f"Module {mid} __IMTCONN__ appears to be a real credential ID "
                   f"(should be a placeholder string)",
                   module_id=mid)

    # MC-002: __IMTCONN__ placeholders follow naming convention
    for mod in all_modules_flat:
        mid = mod.get("id", "?")
        params = mod.get("parameters", {})
        if isinstance(params, dict) and "__IMTCONN__" in params:
            imtconn = params["__IMTCONN__"]
            if isinstance(imtconn, str):
                _check("MC-002",
                       CREDENTIAL_PLACEHOLDER_PATTERN.match(imtconn),
                       f"Module {mid} __IMTCONN__ value '{imtconn}' does not match "
                       f"placeholder pattern __APP_NAME_CONNECTION__",
                       module_id=mid)

    # MC-003: Modules requiring credentials have __IMTCONN__ (if registry available)
    if modules_dict:
        for mod in all_modules_flat:
            mid = mod.get("id", "?")
            mod_type = mod.get("module", "")
            reg_entry = modules_dict.get(mod_type)
            if reg_entry and reg_entry.get("requires_credential"):
                params = mod.get("parameters", {})
                _check("MC-003",
                       isinstance(params, dict) and "__IMTCONN__" in params,
                       f"Module {mid} ('{mod_type}') requires credential but "
                       f"__IMTCONN__ not found in parameters",
                       module_id=mid)

    # ===== MD — Make Designer/Metadata =====

    if isinstance(metadata, dict):
        # MD-001: metadata.scenario exists
        scenario_meta = metadata.get("scenario")
        _check("MD-001", isinstance(scenario_meta, dict),
               "Blueprint metadata missing 'scenario' object")

        # MD-002: metadata.scenario has maxErrors
        if isinstance(scenario_meta, dict):
            _check("MD-002",
                   "maxErrors" in scenario_meta and isinstance(scenario_meta.get("maxErrors"), int),
                   "metadata.scenario missing integer 'maxErrors'")

        # MD-003: metadata.designer exists with orphans array
        designer_meta = metadata.get("designer")
        _check("MD-003",
               isinstance(designer_meta, dict) and isinstance(designer_meta.get("orphans"), list),
               "Blueprint metadata missing 'designer' with 'orphans' array")

    return _build_report(errors, warnings, checks_run, checks_passed)


def _collect_modules_recursive(flow_items, all_ids, all_modules_flat):
    """Recursively collect all module IDs and module dicts from a flow tree.

    Traverses into router routes to find nested modules.

    Args:
        flow_items: List of flow module dicts.
        all_ids: List to append module IDs to (mutated).
        all_modules_flat: List to append module dicts to (mutated).
    """
    for item in flow_items:
        if not isinstance(item, dict):
            continue

        mid = item.get("id")
        if mid is not None:
            all_ids.append(mid)
            all_modules_flat.append(item)

        # Recurse into routes
        routes = item.get("routes", [])
        if isinstance(routes, list):
            for route in routes:
                if isinstance(route, dict):
                    route_flow = route.get("flow", [])
                    if isinstance(route_flow, list):
                        _collect_modules_recursive(route_flow, all_ids, all_modules_flat)


def _validate_routers_recursive(flow_items, errors, warnings, _check):
    """Recursively validate router structure in the flow tree.

    Args:
        flow_items: List of flow module dicts.
        errors, warnings: Lists to append to.
        _check: The check function from the parent scope.
    """
    for item in flow_items:
        if not isinstance(item, dict):
            continue

        mid = item.get("id", "?")
        mod_type = item.get("module", "")

        if mod_type == "builtin:BasicRouter":
            routes = item.get("routes")

            # MT-001: Router has 'routes' array
            _check("MT-001", isinstance(routes, list),
                   f"Router module {mid} missing 'routes' array",
                   module_id=mid)

            if isinstance(routes, list):
                # MT-002: Router has >= 2 routes
                _check("MT-002", len(routes) >= 2,
                       f"Router module {mid} has {len(routes)} route(s), minimum 2 required",
                       module_id=mid)

                # MT-003: Each route has 'flow' array
                for ri, route in enumerate(routes):
                    _check("MT-003",
                           isinstance(route, dict) and isinstance(route.get("flow"), list),
                           f"Router {mid} route[{ri}] missing 'flow' array",
                           module_id=mid)

                    # MT-004: Each route's flow is non-empty
                    if isinstance(route, dict) and isinstance(route.get("flow"), list):
                        _check("MT-004", len(route["flow"]) > 0,
                               f"Router {mid} route[{ri}] has empty flow",
                               warn=True, module_id=mid)

                        # Recurse into route flows
                        _validate_routers_recursive(route["flow"], errors, warnings, _check)

        # Also recurse into non-router modules that might have routes (shouldn't happen, but safe)
        elif "routes" in item and isinstance(item.get("routes"), list):
            for route in item["routes"]:
                if isinstance(route, dict) and isinstance(route.get("flow"), list):
                    _validate_routers_recursive(route["flow"], errors, warnings, _check)


def _build_report(errors, warnings, checks_run, checks_passed):
    """Build the final validation report dict."""
    return {
        "valid": len(errors) == 0,
        "errors": errors,
        "warnings": warnings,
        "checks_run": checks_run,
        "checks_passed": checks_passed,
        "checks_failed": checks_run - checks_passed,
        "timestamp": datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ")
    }


# --- Self-check ---
if __name__ == "__main__":
    import json
    from tools.module_registry_loader import load_module_registry
    from tools.generate_make_export import generate_make_export

    print("=== Validate Make Export Self-Check ===\n")

    registry = load_module_registry()

    # --- Test 1: Valid linear blueprint ---
    print("Test 1: Valid linear blueprint")
    linear_spec = {
        "spec_version": "1.0.0",
        "scenario": {"name": "Test Linear", "description": "Test.", "slug": "test-linear"},
        "trigger": {
            "id": 1, "type": "webhook", "module": "gateway:CustomWebHook",
            "label": "Receive", "version": 1,
            "parameters": {"hook": "__WEBHOOK_ID__"}, "credential_placeholder": None
        },
        "modules": [
            {
                "id": 2, "label": "Parse", "app": "json", "module": "json:ParseJSON",
                "module_type": "transformer", "version": 1,
                "parameters": {}, "mapper": {"json": "{{1.body}}"},
                "credential_placeholder": None, "onerror": None, "resume_value": None
            },
            {
                "id": 3, "label": "Post", "app": "slack", "module": "slack:PostMessage",
                "module_type": "action", "version": 1,
                "parameters": {}, "mapper": {"channel": "#test", "text": "{{2.msg}}"},
                "credential_placeholder": "__SLACK_CONNECTION__",
                "onerror": "ignore", "resume_value": None
            }
        ],
        "connections": [
            {"from": "trigger", "to": 2, "filter": None, "label": None},
            {"from": 2, "to": 3, "filter": None, "label": None}
        ],
        "error_handling": {"default_strategy": "ignore", "max_errors": 3, "module_overrides": []},
        "metadata": {"created_at": "2026-02-16T12:00:00Z", "original_request": "Test."}
    }
    bp1 = generate_make_export(linear_spec)
    report1 = validate_make_export(bp1, registry)

    print(f"  Valid: {report1['valid']}")
    print(f"  Checks: {report1['checks_run']} run, {report1['checks_passed']} passed, {report1['checks_failed']} failed")
    if report1["errors"]:
        for e in report1["errors"]:
            print(f"  ERROR [{e['rule_id']}]: {e['message']}")
    assert report1["valid"], f"Linear blueprint should be valid, got {len(report1['errors'])} errors"
    print("  [OK] Valid linear blueprint passes")

    # --- Test 2: Valid router blueprint ---
    print("\nTest 2: Valid router blueprint")
    router_spec = {
        "spec_version": "1.0.0",
        "scenario": {"name": "Router Test", "description": "Routes.", "slug": "router-test"},
        "trigger": {
            "id": 1, "type": "webhook", "module": "gateway:CustomWebHook",
            "label": "Receive", "version": 1,
            "parameters": {"hook": "__WEBHOOK_ID__"}, "credential_placeholder": None
        },
        "modules": [
            {
                "id": 2, "label": "Route", "app": "builtin", "module": "builtin:BasicRouter",
                "module_type": "flow_control", "version": 1,
                "parameters": {}, "mapper": {},
                "credential_placeholder": None, "onerror": None, "resume_value": None
            },
            {
                "id": 3, "label": "Slack", "app": "slack", "module": "slack:PostMessage",
                "module_type": "action", "version": 1,
                "parameters": {}, "mapper": {"channel": "#alerts", "text": "{{1.msg}}"},
                "credential_placeholder": "__SLACK_CONNECTION__",
                "onerror": None, "resume_value": None
            },
            {
                "id": 4, "label": "Sheets", "app": "google-sheets", "module": "google-sheets:addRow",
                "module_type": "action", "version": 2,
                "parameters": {"spreadsheetId": "__SID__", "sheetId": "__SHID__"},
                "mapper": {"values": ["{{1.data}}"]},
                "credential_placeholder": "__GOOGLE_SHEETS_CONNECTION__",
                "onerror": None, "resume_value": None
            }
        ],
        "connections": [
            {"from": "trigger", "to": 2, "filter": None, "label": None},
            {"from": 2, "to": 3, "filter": {
                "name": "Urgent", "conditions": [[{"a": "{{1.level}}", "b": "urgent", "o": "text:equal"}]]
            }, "label": "Urgent"},
            {"from": 2, "to": 4, "filter": None, "label": "All"}
        ],
        "error_handling": {"default_strategy": "ignore", "max_errors": 5, "module_overrides": []},
        "metadata": {"created_at": "2026-02-16T12:00:00Z", "original_request": "Route."}
    }
    bp2 = generate_make_export(router_spec)
    report2 = validate_make_export(bp2, registry)

    print(f"  Valid: {report2['valid']}")
    print(f"  Checks: {report2['checks_run']} run, {report2['checks_passed']} passed, {report2['checks_failed']} failed")
    if report2["errors"]:
        for e in report2["errors"]:
            print(f"  ERROR [{e['rule_id']}]: {e['message']}")
    assert report2["valid"], f"Router blueprint should be valid, got {len(report2['errors'])} errors"
    print("  [OK] Valid router blueprint passes")

    # --- Test 3: Invalid blueprint (multiple issues) ---
    print("\nTest 3: Invalid blueprint")
    bad_bp = {
        "name": 123,  # wrong type
        "flow": [
            {"id": "not_int", "module": 456, "version": "bad"},  # wrong types
            {"id": 1, "module": "gateway:CustomWebHook", "version": 1},  # duplicate? no, but missing metadata
        ],
        "metadata": {"scenario": {"maxErrors": "three"}}  # wrong type
    }
    report3 = validate_make_export(bad_bp, registry)

    print(f"  Valid: {report3['valid']}")
    print(f"  Errors: {len(report3['errors'])}")
    assert not report3["valid"], "Bad blueprint should fail"
    error_rules = {e["rule_id"] for e in report3["errors"]}
    print(f"  Rules triggered: {sorted(error_rules)}")
    assert "MR-002" in error_rules, "Should catch non-string name"
    assert "MF-001" in error_rules, "Should catch non-integer module ID"
    assert "MF-005" in error_rules, "Should catch non-string module type"
    print("  [OK] Invalid blueprint correctly rejected")

    # --- Test 4: Blueprint without registry (basic checks only) ---
    print("\nTest 4: Validation without registry")
    report4 = validate_make_export(bp1)  # no registry
    print(f"  Valid: {report4['valid']}")
    assert report4["valid"], "Should still pass basic structural checks without registry"
    print("  [OK] Passes basic checks without registry")

    # --- Test 5: Completely empty object ---
    print("\nTest 5: Empty object")
    report5 = validate_make_export({})
    assert not report5["valid"]
    print(f"  Errors: {len(report5['errors'])}")
    print("  [OK] Empty object rejected")

    # --- Test 6: Determinism ---
    print("\nTest 6: Determinism")
    report6a = validate_make_export(bp2, registry)
    report6b = validate_make_export(bp2, registry)
    # Compare everything except timestamp
    assert report6a["valid"] == report6b["valid"]
    assert report6a["checks_run"] == report6b["checks_run"]
    assert report6a["checks_passed"] == report6b["checks_passed"]
    assert len(report6a["errors"]) == len(report6b["errors"])
    print("  [OK] Deterministic output")

    print(f"\n=== All validate_make_export checks passed ===")
